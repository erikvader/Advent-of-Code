(ql:quickload "aoc")
(use-package :iterate)
(use-package :alexandria)
(use-package :arrows)

(defun incf-leftest (tree n)
  (cond ((numberp tree)
         (+ tree n))
        ((and (consp tree)
              (numberp (car tree)))
         (incf (car tree) n)
         tree)
        (t
         (incf-leftest (car tree) n)
         tree)))

(defun incf-rightest (tree n)
  (cond ((numberp tree)
         (+ tree n))
        ((and (consp tree)
              (numberp (cdr tree)))
         (incf (cdr tree) n)
         tree)
        (t
         (incf-rightest (cdr tree) n)
         tree)))

(defun explode (ns h)
  (assert (< h 4))
  (cond
    ((numberp ns)
     nil)
    ((and (numberp (car ns))
          (numberp (cdr ns)))
     nil)
    ((and (= h 3)
          (consp (car ns)))
     (setf (cdr ns) (incf-leftest (cdr ns) (cdar ns)))
     (prog1 (cons :left (caar ns))
       (setf (car ns) 0)))
    ((and (= h 3)
          (consp (cdr ns)))
     (setf (car ns) (incf-rightest (car ns) (cadr ns)))
     (prog1 (cons :right (cddr ns))
       (setf (cdr ns) 0)))
    (t
     (let ((dir (explode (car ns) (1+ h))))
       (cond ((and (consp dir)
                   (eq (car dir) :left))
              dir)
             ((and (consp dir)
                   (eq (car dir) :right))
              (setf (cdr ns) (incf-leftest (cdr ns) (cdr dir)))
              t)
             ((eq dir 't)
              t)
             (t
              (let ((dir (explode (cdr ns) (1+ h))))
                (cond ((and (consp dir)
                            (eq (car dir) :right))
                       dir)
                      ((and (consp dir)
                            (eq (car dir) :left))
                       (setf (car ns) (incf-rightest (car ns) (cdr dir)))
                       t)
                      (t dir)))))))))

(defun split (ns)
  (cond
    ((numberp ns)
     nil)
    ((split (car ns))
     t)
    ((and (consp ns)
          (numberp (car ns))
          (>= (car ns) 10))
     (setf (car ns) (cons (floor (car ns) 2)
                          (ceiling (car ns) 2)))
     t)
    ((split (cdr ns))
     t)
    ((and (consp ns)
          (numberp (cdr ns))
          (>= (cdr ns) 10))
     (setf (cdr ns) (cons (floor (cdr ns) 2)
                          (ceiling (cdr ns) 2)))
     t)))

(defun simplify (ns)
  (iter (iter (while (explode ns 0)))
        (while (split ns)))
  ns)

(defun add (n1 n2)
  (let ((res (cons n1 n2)))
    (simplify res)))

(defun magnitude (ns)
  (if (consp ns)
      (+ (* 3 (magnitude (car ns)))
         (* 2 (magnitude (cdr ns))))
      ns))

(defun part1 (numbers)
  (magnitude
   (reduce #'add numbers)))

(defun part2 (numbers)
  (iter outer (for n1 in numbers)
        (iter (for n2 in numbers)
              (when (not (eq n1 n2))
                (in outer (maximize (magnitude (add (copy-tree n1) (copy-tree n2)))))))))

(defparameter *parser* (aoc:each-line 'list (aoc:parse-conses "[" "]" ",")))
(aoc:run-day #'part1 :parser *parser*
                     :expected-answer 3793)

(aoc:run-day #'part2 :parser *parser*
                     :expected-answer 4695)
